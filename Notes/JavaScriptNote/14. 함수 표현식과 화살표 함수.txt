1. intro
    1) JavaScript 코드의 80%는 함수로 이루어져 있음
    2) 화살표 함수를 기본으로 사용
    3) 코드 가독성 

2. 함수 선언
    1) function 키워드로 시작
    2) 함수 이름 필수
    3) 호이스팅 0   
        - 선언 전에도 호출 가능
    4) ex
        - function addDeclaration(a, b) {   // a, b는 매개변수(parameter) : 호출되서 받을 값의 이름
            return a + b;           // 함수 실행 결과를 반환
        }

        addDeclaration(10, 20)  // 10, 20은 인수(argument) : 함수 호출 시에 전달되는 값

3. 함수 표현식 (Function Express)
    1) 함수를 변수에 할당하는 방식
    2) 함수도 "값"처럼 취급 됨
    3) const: 상수 선언 (재할당 불가)
    4) ex
        - const addExpression = function(a ,b) {
            return a + b;
        };
    5) 익명 함수
    6) 호이스팅 X : 선언 후에만 호출 가능
    7) 변수 할당문으로 세미콜론 필수

4. 화살표 함수
    1) ES6에서 도입된 간결한 함수 표현 방식
    2) function 키워드 대신 =>(화살표) 사용
    3) 중괄호 {}를 사용하면 return 키워드가 명시적으로 필요함
    4) ex
        - const addArrow = (a, b) => a + b; // return이 필요한 {}를 생략하는 경우
    5) 축약형 (가장 많이 사용)
        - 본문이 한 줄(표현식 하나)일 때 더 짧게 작성
        - (a,b) => {return a + b;}; 와 동일
        - { } + return 생략(암시적 반환)
            - (a, b) => a + b;

    6) 매개변수 개수에 따른 괄호 규칙
        - 매개변수 1개 --> () 생략 가능
        - ex
            - const doubleVar = x => x * 2;
        - 매개변수 0개 --> () 필수
        - ex
            - const sayHello = () => "안녕!"
        - 빈 괄호는 반드시 필요 (생략 불가)
        - 고정 값 반환

5. 배열 메서드
    1) 화살표 함수는 배열 메서드와 함께 가장 많이 사용됨
   
    2) map()
        - 변환(mapping)하다
        - 배열의 각 요소를 변환하여 새 배열 반환
        - 원본 배열은 그대로, 새 배열을 생성
        - ex
            const numbers = [1, 2, 3, 4, 5];
            const doubleVar = numbers.map(n => n * 2); // 각 n번째의 요소를 받아 n * 2로 변환함

            - flow
                - [1, 2, 3, 4, 5]   --->(*2)    [2, 4, 6, 8, 10]


        - 새로운 형태의 객체로 변환
            - 화살표 함수에서 { }는 2개의 의미가 있음
                - 함수 본문(body)을 나타내는 중괄호 : () => {code...}
                - 객체 리터럴을 나타내는 중괄호 : {key: value}
            
            - JavaScropt 엔진은 { }를 보면 "함수 본문"으로 먼저 해석함
                - solution 1. 소괄호 ( )로 감싸기 => 표현식으로 해석하도록(JS 엔진이 { }를 객체 리터럴로 해석)

                - 명시적 return 사용 => return 두의 { }는 개체 리터럴로 해석함
                  
    
    3) filter()
        - 걸러내다
        - 조건을 만족하는 요소만 걸러서 새 배열 반환 
        - 원본 배열은 그대로
        - 콜백이 true면 포함, false면 제외
        - ex
            const numbers = [1, 2, 3, 4, 5];
            const evens = numbers.filter(n => n % 2 === 0)    // n번째 요소가 짝수인지 확인

            - flow
                - [1, 2, 3, 4, 5]   --->(짝수인지 확인)    [2, 4]

    4) reduce()
        - 줄이다
        - 배열의 모든 요소를 하나의 값으로 축소
        - ex
            const numbers = [1, 2, 3, 4, 5];
            const sum = numbers.reduce((acc, n) => acc + n, 0)  // 0: 초기값 (acc의 시작값)
                                                                // acc가 누산기의 카운터로 작동함


6. 콜백 함수와 고차 함수 (Higher-Order Function)
    1) 고차 함수
        - 함수를 매개변수로 받는 함수
        - ex
            const addAndCallback = (a, b, callback) => {
                let result = a + b + c;     // step 1 : 계산
                callback(result);            // step 2 : 콜백 실행
            }

            - callback : 세번째 매개변수로 "함수"를 받음
            - 계산 (a+b)은 여기서 하고, 결과 처리는 전달 받은 함수(callback)에 위임
            - 실행 흐름
                - 1) a=5, b=3, callback = showResult로 호출 
                - 2) result = 5 + 3 = 8
                - 3) showResult(8) 실행 ---> "8" 출력 (showDouble(8) 실행)
    
    2) 콜백 함수 정의 - 결과를 처리하는 함수
        - ex (결과를 단순히 출력하는 함수)

            const showResult = (result) => {    // 매개변수 result: addAndCallback에서 전달 받은 값
                console.log('결과: ' + result);
            }

        - ex (결과를 2배로 만드는 함수)

            const showDouble = (result) => {
                console.log('2배: ' +result * 2);
            }

        - 같은 result를 매개변수로 받지만 처리를 다르게함 (콜백의 유연함)

7. 익명 함수 (Anonymous Function) - 이름 없이 바로 전달
    1) 함수에 이름 붙이지 않고 바로 전달
    2) 일회성 사용에 편리
    3) 콜백 내부에서 어떤 연산이든 자유롭게 수행 가능
    4) ex
        calculateAndProcess(10, 5, (result) => {
            consol.log(result * result);    // 15 * 15 = 225
        })
