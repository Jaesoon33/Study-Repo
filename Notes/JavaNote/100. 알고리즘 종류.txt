1. 대표적인 알고리즘 4가지
	1) Greedy Algorithm 
		- 핵심: "매 순간 가장 좋아 보이는 것을 선택"
		- ex) 거스름돈, 회의실 배정, 최소 신장 트리(Spanning Tree)
		- 특징: 구현 쉬움 / 빠름 / 단 항상 최적의 '해'는 아님
		- 왜 이 알고리즘을 먼저 학습하는가?
			- 직관적이고 이해하기 쉬움
			- 코드 구현이 간단
			- 실생활 예시가 풍부
			
2. Greedy Algorithm 
	1) 핵심 개념
		- 미래를 고려하지 않고, 현재 상황에서 최적의 선택을 반복함
	2) 비유
		- 등산할 때
			- 지금 보이는 가장 가파른 길로 올라가면 정상에 도달할 수 있다
		- 거스름돈 계산
			- 가장 큰 단위의 동전/지폐부터 먼저 사용하면 최소 개수로 거슬러줄 수 있다
			- 매 순간마다 가장 큰 단위를 선택
	3) 장단점
		- 장점 
			- 구현이 간단하고 직관적
			- 실행 속도가 빠름
			- 코드가 짧고 이해하기 쉬움
			- 특정 조건에서 최적 해를 보장
				- 거스름돈 문제는 화폐 단위가 배수관계일 때 최적해 보장
		- 단점(notice)
			- 항상 최적의 해를 보장하지 않음
			- 한번 선택하면 번복 불가
			
3. 거스름돈 계산 알고리즘
	1) 핵심 원리
		- 가장 큰 단위부터 처리하면 최소 개수의 동전/지폐로 거스름돈을 만들 수 있음
		
	2) ex
		- 거스름돈 + 2,760원
		
		- 1단계 1,000원
			- tempChange = 2760;
			  나눗셈(몫): coins500 = oins 1000 = 2760 / 1000 = 2 --> 1,000원권 2장
			  나머지(%): tempChange = 2760 % 1000 = 760 --> 남은 금액 760원 
		- 2단계 500원
			- tempChange = 760;
			  나눗셈(몫): coins500 = 760 / 500 = 1 --> 500원 1개
			  나머지(%): tempChange = 760 % 500 = 260 --> 남은 금액 660원 
		- 3단계 100원
			- tempChange = 260;
			  나눗셈(몫): coins100 = 260 / 100 = 2 --> 100원 2개
			  나머지(%): empChange = 260 % 100 = 60 --> 남은 금액 60원 
		- 3단계 50원
			- tempChange = 60;
			  나눗셈(몫): coins50 = 60 / 50 = 1 --> 50원 1개
			  나머지(%): empChange = 60 % 50 = 10 --> 남은 금액 10원
		- 3단계 10원
			- tempChange = 10;
			  나눗셈(몫): coins10 = 10 / 10 = 1 --> 10원 1개
			  나머지(%): empChange = 10 % 10 = 0 --> 남은 금액 0원 (끝)