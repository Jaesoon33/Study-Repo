1. 스레드 생성 방법 3가지
    1) 방법1 : Thread 상속
        - 단일 상속
        - 다른 클래스 상속 불가 

    2) 방법2 : Runnable 구현 
        - 다른 클래스 상속 가능 
        - 작업/실행 분리 
        - Runnable task = new Runnable() { run() {...} } <--- 작업을 정의!
           --> 이 task를 Thread 생성자에 전달:  new Thread(task)      

    3) 방법3 : Anonymous Thread(익명 객체) & Lambda Thread(람다식)
        - 간결, 유연, 가독성
        - 익명 객체 구현 방식
            - new Runnable() { @Override public void run() {...}}
            - 코드가 장황함 (보일러플레이트 많음)
            - Java 8 이전에 사용하던 방식
        - 람다식 방식 (실무 권장)
            - () -> {...}
            - 핵심 로직만 남기고 나머지 생략 --> 가독성
            - Java 8+ 에서 사용 가능 (Runnable = 함수형 인터페이스)
            - 실무에서 90% 이상 이 방식 사용!

2. 주의 사항
    1) start()를 호출해야 새 스레드 생성
    2) run()을 직접 호출하면 메인 스레드에서 실행됨 
    3) 종료된 스레드는 다시 start() 불가 
        - 새 Thread 객체를 만들어야 함 

3. 스레드 생명주기 (Thread.State)
    1) 스레드가 어떤 상태를 거치는지(생명주기) 확인
    2) 비유
        - 스레드 (자동차)
        - 생명주기 (자동차가 달리는 도로 지도)
        - 코드 작성 (자동차 조립 | start() = 시동 걸기 | run() 끝 = 시동 끄기 )
    3) Java 스레드는 6가지 상태를 가짐 
        - RUNNABLE에서 3가지 대기 상태로 갔다가 다시 RUNNABLE로 돌아옴         

4. Runnable 구현 방식 
    1) 작업과 실행의 분리
    2) Runnable을 implements한 객체를 Thread 생성자에 전달 
    3) 장점
        - 다른 클래스 상속 가능
        - 작업(Runnable)과 실행(Thread) 분리 --> 실무에서 선호 
    4) Runnable은 run() 메서드 하나만 가진 함수형 인터페이스 --> 람다 사용 가능
    5) 예
        [작업 (What to do)]         ----------주입(전달)------>        [실행 (How to run)]
        CountTask task = new CountTask(5);                        Thread t = new Thread(task, "count-Thread");         
                                                                   t.start();    // OS 스레드 생성 -> run() 실행 

5. 데몬 스레드 (Daemon)
    0) 주 스레드 (메인)를 보조하는 백그라운드 스레드 
    1) 주 스레드 (메인)가 종료되면 자동으로 강제 종료되는 백그라운드 보조 스레드 
        - 일반 스레드는 주 스레드 종료와 무관하게 계속 실행
    2) 보조 작업을 하는 스레드 
        - GC(가비지 컬렉터), 자동저장, 모니터링, 로깅
    3) setDaemon(true) -- start() 전에 호출            
    4) 데몬만 남으면 --> JVM 종료
        - 일반 스레드 1개라도 있으면 --> JVM 유지   
    5) 비유 (사무실)
        - 일반 스레드 = 정규 직원
            - 직원 남아있으면 사무실(JVM) 계속 운영
        - 데몬 스레드 = 자동 에어컨/조명 
            - 직원 다 퇴근하면 자동으로 꺼짐
        - 에어컨(데몬)이 아무리 실행하고 있어도, 직원(일반) 없으면 사무실 문 닫음
    6) 데몬 스레드에서 하면 안 되는 것
        - 파일 쓰기 (중간에 잘릴 수 있음!)
        - DB 트랜잭션 (커밋 전 종료 가능!)
        - 중요한 데이터 처리
    7) 데몬 스레드의 상태 전이
                    start()                   sleep(200)                  메인종료시
        NEW     ---------------> RUNNABLE <---------------> TIME_WAITING ---------> TERMINATED  
        (생성)                    (실행가능)                    (sleep 중)             (JVM 강제 종료)
                                    while(true) : 반복
                                             (데몬은 무한 루프가 일반적)     

6. 멀티 스레딩과 동기화 
    1) 여러 개의 스레드가 동시에 같은 메모리의 값을 변경하는 작업 수행하면 
       그 값은 기대하는 값과 크게 다를 수 있음.
    2) 멀티 스레딩에서 가장 주의해야 할 부분 
        - 여러 스레드가 번갈아 실행되면서 같은 자원을 공유한다는 점
        - 같은 자원
            - 메모리 
            - IO 장치 
    3) 동기화 (Synchronization)
        - 멀티스레딩 상황에서 여러 개의 스레드가 공유 자원에 동시에 접근하려 할때,
          하나의 스레드만 접근하도록 하고 나머지 접근을 막아(blocking)
          순차로 접근하도록 하는 방법 
    4) 스레드 동기화 
        - 용어
            - Critical Section (임계 영역)
                - 한 번에 하나의 스레드만 실행해야 하는 코드 구간 
        - synchronized 메서드 
            - 메서드 전체를 임계 영역으로 지정 
        - synchronized 블록 
            - 특정 코드 블록만 임계 영역으로 지정 (더 세밀한 제어)
        - wait() / notify()
            - wait()는 락을 반납하고 대기
            - notify()는 대기 중인 스레드를 깨움 
            - synchronized 안에서 호출
        - join()
            - 다른 스레드가 끝날 때까지 현재 스레드를 기다리게 하는 메서드 
                - 호출하는 스레드 (main) --> WAINTING 상태로 전환
                - 대상 스레드 (thread) --> 이 스레드가 종료되면 
                - 호출하는 스레드 (main) --> 다시 RUNNABLE 상태로 복귀                                                                                   