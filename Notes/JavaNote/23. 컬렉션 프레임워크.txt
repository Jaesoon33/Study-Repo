0. 컬렉션 프레임 워크
	1) 일상에서 이미 쓰고 있는 컬렉션 
		- 카카오톡 채팅방
			- 메시지가 순서대로 쌓임
			- 새 메시지는 맨 아래에 추가
			- 스크롤 시 위에서부터 읽음
			=> List임 (순서 O, 중복 O)
		- 수강생 출석체크
			- 같은 이름은 한번만 체크
			- 순서 상관 X
			- 누가 왔는지만 중요
			=> Set임 (순서 없고, 중복 불허)
		- 연락처 (전화번호부)
			- 이름으로 번호를 찾음
			- 이름이 Key, 번호가 Value
			- 같은 이름(Key) 중복 불가
			=> Map (Key로 Value를 찾는 구조)

1. 배열의 한계
	1) 크기 변경 불가 (선언 시 배열의 크기도 선언 --> 처음에 몇 개의 요소가 생성될지 모르면?)
	2) 중간 삽입/삭제 (--> 빈자리에 대한 뒤의 요소들이 앞으로 채워져아함 --> 추가 연산 필요)
	3) 현재 몇 개 들어있는지 직접 관리해야함
	4) 배열을 쓰는 경우
		- 크기가 절대 변하지 않을 때 (ex: 요일, month)
	
2. ArrayList
	1) 크기 자동 조절 --> 데이터가 몇 개든 문제 없음
	2) add/remove()	--> 추가/삭제 메서드 제공
	3) size()	--> 현재 개수를 자동 관리
	4) ArrayList 쓰는 경우
		- 데이터가 동적으로 추가/삭제 될 때(ex. 직원 목록, 주문 목록, 로또 

3. 배열 vs ArrayList 메서드 비교
		
		기능				배열(Array)				ArrayList
	---------------------------------------------------------
		생성             new String[3]			new ArrayList<>()
		추가				arr[0] = "값"			list.add("값")
		조회				arr[0]					list.get(0)
		크기				arr.length				list.size()
		삭제				(직접 구현 필요)			list.remove(0
		포함 여부			(직접 반복문 실행)			list.contain("값")
		
4. ArrayList vs HashSet 중복 처리 방식 비교		// equals()를 오버라이드할 시에는 hashCode도 반드시 오버라이드 해야함
												// equals가 true인 두 객체는 같은 hashCode를 가져야 하는 규엑 때문

		비교 항목				ArrayList + contain()			HashSet
	--------------------------------------------------------------------
		중복 처리			수동 체크 필요(contains --> equals)	자동 차단(add() 시)
		사용하는 메서드	equals()만 사용하는					Has

5. 실무 사용 빈도
	1) ArrayList
		- 가장 많이 사용
		- ex) DB에서 특정 데이터를 조회한 결과, API 응답 데이터 등
		
	2) HashMap
		- 두 번째로 많이 씀